<?xml version="1.0" encoding="UTF-8"?>
<chapter id="writing.specs.with.phpspec">
  <title>Writing Specs with PHPSpec</title>

  <section id="specs.examples.and.contexts">
    <title>Specs, Examples and Contexts</title>

    <para>The terminology used throughout Behaviour-Driven Development is
    focused entirely on the concept of describing behaviour. This alleviates
    any misunderstanding from attempting to describe the process of
    Test-Driven Development in terms of tests - a counterintuitive notion for
    many programmers.</para>

    <para>The terms Spec<indexterm>
        <primary>Spec</primary>

        <seealso>Specification</seealso>
      </indexterm> and Example<indexterm>
        <primary>Example</primary>

        <seealso>Spec</seealso>
      </indexterm> are almost used interchangeably. While a Spec refers to a
    single behavioural requirement, often captured as a simple sentence of the
    form "it should do something", an Example refers to the the entire method
    within PHPSpec which demonstrates this Spec in code. If you take the
    example below, the spec is the line of code commencing with
    <classname>$this-&gt;spec()</classname> and the example is the entire
    public method which shows how this spec is achievable</para>

    <example>
      <title>A Spec in a PHPSpec Example Method</title>

      <programlisting role="php">public function itShouldHaveScoreOfZero()
{
    $bowling = new Bowling;
    $bowling-&gt;hit(0);
    $this-&gt;spec($bowling-&gt;score)-&gt;should-&gt;be(0);
}</programlisting>

      <para>A more difficult concept is that of a Context<indexterm>
          <primary>Context</primary>
        </indexterm>. In brief a Context is the set of conditions prevailing
      at the time we are specifying behaviour. Above, our Bowling example
      assumes we've just started a new game. This is the Context all our Specs
      in the same class would share. Later we might want a game which is
      finished, or partially played. Each different Context helps you explore
      how behaviour changes under different conditions.</para>
    </example>
  </section>

  <section id="before.writing.code.specify.its.required.behaviour">
    <title>Before Writing Code, Specify Its Required Behaviour</title>

    <para>In the course of developing a new application we've determined we
    need a Logging<indexterm>
        <primary>Logging</primary>

        <secondary>example in PHPSpec</secondary>
      </indexterm> system, perhaps to store an audit trail. We're going to
    assume no current open source Logger library is sufficient for our needs
    and we are required to develop one from scratch. before we can do anything
    we need to start figuring out what it needs to do. In other words, how we
    want it to behave. After consulting with our colleagues we determine at
    least one fundamental requirement - to log messages to a
    filesystem.</para>

    <para>Rather than immediately jumping into an editor to start coding,
    we're going to write the specifications<indexterm>
        <primary>Specifications</primary>

        <secondary>plain text</secondary>
      </indexterm> first.</para>

    <example>
      <title>Some plain text specifications for a filesystem Logger</title>

      <para>New Filesystem Logger:</para>

      <para>- should create a new log file if none currently exists</para>

      <para>- should use an existing log file if one exists without truncating
      it</para>

      <para>- should throw Exception if existing log file not writeable</para>
    </example>

    <para>These simple plain text specifications can be translated to PHPSpec
    by creating a new Context class contain the examples demonstrating these
    behaviours.</para>

    <programlisting role="php">class DescribeNewFilesystemLogger extends PHPSpec_Context
{

    public function itShouldCreateCreateNewLogFileIfNoneExists()
    {
        $this-&gt;pending();
    }

    public function itShouldUseAnExistingLogFileIfOneExistsWithoutTruncatingIt()
    {
        $this-&gt;pending();
    }

    public function itShouldThrowExceptionIfExistingLogFileNotWriteable()
    {
        $this-&gt;pending();
    }

}</programlisting>

    <para>This skeleton class has two Pending<indexterm>
        <primary>pending specs</primary>
      </indexterm> examples. The pending status simply means they are
    incomplete or pending completion. If you were to execute this spec from
    the command line when saved as DescribeNewFilesystemLogger.php, the output
    would look something like:</para>

    <screen>PPP

Finished in 0.0468921661377 seconds

3 examples, 0 failures, 3 pending</screen>

    <para>We now have two example methods. Based on the defined
    specifications, let's fill these in with something useful.</para>

    <example>
      <title>Specification for a New Filesystem Logger Context</title>

      <programlisting role="php">class DescribeNewFilesystemLogger extends PHPSpec_Context
{

    public function itShouldCreateCreateNewLogFileIfNoneExists()
    {
        $file = $this-&gt;getTmpFileName();
        $logger = new Logger($file);
        $this-&gt;spec(file_exists($file))-&gt;should-&gt;beTrue();
    }

    public function itShouldUseAnExistingLogFileIfOneExistsWithoutTruncatingIt()
    {
        $file = $this-&gt;getTmpFileName();
        file_put_contents($file, 'Hello' . "\n");
        $logger = new Logger($file);
        $this-&gt;spec(file_get_contents($file))-&gt;shouldNot-&gt;beEmpty();
    }

    public function itShouldThrowExceptionIfExistingLogFileNotWriteable()
    {
        $file = $this-&gt;getTmpFileName();
        file_put_contents($file, 'Hello' . "\n");
        $this-&gt;spec('Logger', $file)-&gt;should-&gt;throw('Exception');
    }

    public function after()
    {
        unlink($this-&gt;getTmpFileName());
    }

    public function getTmpFileName()
    {
        return sys_get_temp_dir() . DIRECTORY_SEPARATOR . 'logger_tmp_file.log';
    }

}</programlisting>
    </example>

    <para>And so we've now turned our plain text specs into coded examples for
    execution. Of course executing this now will result in an ugly Fatal Error
    since the Logger class does not yet exist. We'll cross this bridge later
    on.</para>

    <section id="explaining.the.phpspec.spec.layout">
      <title>Explaining the PHPSpec Spec Layout</title>

      <para>Our completed New Filesystem Logger example demonstrates how a
      Spec<indexterm>
          <primary>Spec</primary>

          <secondary>API and layout</secondary>
        </indexterm> is put together.</para>

      <orderedlist>
        <listitem>
          <para>All Specs are aggregated within a PHPSpec_Context subclass
          based on the condition of the system being specified</para>
        </listitem>

        <listitem>
          <para>All Context classnames must begin with the term "Describe" to
          encourage full sentence descriptions</para>
        </listitem>

        <listitem>
          <para>All Example methods in a Context must begind with "itShould",
          again to encourage full sentence specification text</para>
        </listitem>

        <listitem>
          <para>A <classname>PHPSpec_Context::spec()</classname> method is
          utilised to prepare any object or scalar value for expectations via
          the DSL.</para>
        </listitem>

        <listitem>
          <para>The domain specific langauge (DSL) generally includes an
          Expectation (should/shouldNot) and a Matcher (beSomething,
          haveSomething, etc.)</para>
        </listitem>

        <listitem>
          <para>It is almost a rule that you only have one Spec per Example -
          this ensures each Spec is a single isolated piece of
          behaviour</para>
        </listitem>

        <listitem>
          <para>You can add any other methods to the class to provide Helper
          Methods, e.g. <classname>getTmpFileName()</classname></para>
        </listitem>

        <listitem>
          <para>You can use <classname>after()</classname> and
          <classname>before()</classname> methods to setup common Fixtures for
          each Example</para>
        </listitem>

        <listitem>
          <para>You can also use <classname>afterAll()</classname> and
          <classname>beforeAll()</classname> methods with are run only once
          before and after all Examples are executed</para>
        </listitem>

        <listitem>
          <para>Note that any Exceptions or Errors triggered with an Example
          will be reported but will not interrupt any other tests</para>
        </listitem>
      </orderedlist>
    </section>

    <section id="the.code.to.implement.the.new.filesystem.logger.specification">
      <title>The Code To Implement The New Filesystem Logger
      Specification</title>

      <para>With our specification now written up with PHPSpec, we can move on
      and implement the Logger to its specifications. I'm sure many people
      will note some paths for refactoring but for now we're only interested
      in writing the minimum amount of code necessary to pass all our
      Specs.</para>

      <example>
        <title>Implementation of the Filesystem Logger</title>

        <programlisting role="php">class Logger
{

    protected $_file = null;

    public function __construct($file)
    {
        if (!file_exists($file)) {
            $f = fopen($file, 'w');
            fclose($f);
        } elseif (file_exists($file) &amp;&amp; is_writeable($file)) {
            $this-&gt;_file = $file;
        } else {
            throw new Exception('log file is not writeable'); 
        }
    }

}</programlisting>
      </example>

      <para>The next step is deciding what the next behaviour should be so we
      can write a Spec for it. Maybe you want to add a Logger_Exception class
      to extend Exception? Maybe the file needs a few more checks? Maybe you
      want to consider moving file handling to a new subclass or strategy
      class for composition?</para>

      <para>Whatever you would decide - write a spec for it before adding more
      code. Take small steps and build up your classes iteratively. Remember
      also not to over-specify. Just because you extract file handling to a
      new class does not mean you should immediately specify the new class
      (unless it's valuable enough to warrant it) since the original Specs
      still cover the effects of a Logger being instantiated with a file. This
      is not adding new behaviour - it's just changing the implementation of
      that behaviour transparently.</para>
    </section>
  </section>
</chapter>